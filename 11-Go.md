# Go Programming - ĞÑ‚Ğ²ĞµÑ‚Ñ‹ Ğ½Ğ° Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²ÑŒÑ

## ğŸ“š Ğ¢ĞµĞ¾Ñ€Ğ¸Ñ

### 1. Goroutines Ğ¸ Channels

**Ğ’Ğ¾Ğ¿Ñ€Ğ¾Ñ:** ĞĞ±ÑŠÑÑĞ½Ğ¸Ñ‚Ğµ, ĞºĞ°Ğº Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ÑÑ‚ goroutines Ğ¸ channels Ğ² Go. Ğ’ Ñ‡ĞµĞ¼ Ñ€Ğ°Ğ·Ğ½Ğ¸Ñ†Ğ° Ğ¼ĞµĞ¶Ğ´Ñƒ buffered Ğ¸ unbuffered channels?

**ĞÑ‚Ğ²ĞµÑ‚:**

**Goroutine** â€” Ğ»ĞµĞ³ĞºĞ¾Ğ²ĞµÑĞ½Ñ‹Ğ¹ Ğ¿Ğ¾Ñ‚Ğ¾Ğº Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ, ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼Ñ‹Ğ¹ Go runtime (Ğ½Ğµ OS thread).

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Go Runtime Scheduler                      â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  M:N Scheduling                                      â”‚   â”‚
â”‚  â”‚                                                      â”‚   â”‚
â”‚  â”‚  Goroutines (G) â”€â”€â–º OS Threads (M) â”€â”€â–º Processors (P)â”‚   â”‚
â”‚  â”‚                                                      â”‚   â”‚
â”‚  â”‚  Many Goroutines â”€â”€â–º Fewer OS Threads              â”‚   â”‚
â”‚  â”‚  (User-space scheduling)                             â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                              â”‚
â”‚  Goroutine: ~2KB stack (vs ~1MB thread)                     â”‚
â”‚  Context switch: faster (no kernel involvement)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ goroutine:**
```go
// ĞŸÑ€Ğ¾ÑÑ‚Ğ¾Ğ¹ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€
go func() {
    fmt.Println("Running in goroutine")
}()

// Ğ¡ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ°Ğ¼Ğ¸
for i := 0; i < 10; i++ {
    go func(n int) {
        fmt.Printf("Goroutine %d\n", n)
    }(i)  // Ğ’Ğ°Ğ¶Ğ½Ğ¾: Ğ¿ĞµÑ€ĞµĞ´Ğ°ĞµĞ¼ ĞºĞ¾Ğ¿Ğ¸Ñ
}
```

**Channels:**

```go
// Unbuffered channel (ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ñ‹Ğ¹)
ch := make(chan int)
// ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµÑ‚ÑÑ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°Ñ‚ĞµĞ»Ñ
// ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµÑ‚ÑÑ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ĞµĞ»Ñ

// Buffered channel (Ğ°ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ñ‹Ğ¹ Ğ´Ğ¾ capacity)
ch := make(chan int, 10)
// ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµÑ‚ÑÑ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞºĞ¾Ğ³Ğ´Ğ° buffer Ğ¿Ğ¾Ğ»Ğ¾Ğ½
```

**Unbuffered vs Buffered:**

```
Unbuffered Channel:
Sender â”€â”€â–º [ ] â”€â”€â–º Receiver
           â”‚
      (Synchronization point)

Buffered Channel:
Sender â”€â”€â–º [1][2][3] â”€â”€â–º Receiver
           Capacity = 3
```

**Select:**
```go
select {
case msg1 := <-ch1:
    fmt.Println("Received from ch1:", msg1)
case msg2 := <-ch2:
    fmt.Println("Received from ch2:", msg2)
case ch3 <- 100:
    fmt.Println("Sent to ch3")
default:
    fmt.Println("No channel ready")
}
```

---

### 2. Interfaces

**Ğ’Ğ¾Ğ¿Ñ€Ğ¾Ñ:** ĞšĞ°Ğº Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ÑÑ‚ interfaces Ğ² Go? ĞĞ±ÑŠÑÑĞ½Ğ¸Ñ‚Ğµ duck typing Ğ¸ empty interface.

**ĞÑ‚Ğ²ĞµÑ‚:**

**Interface** â€” ÑÑ‚Ğ¾ Ñ‚Ğ¸Ğ¿, Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ÑÑÑ‰Ğ¸Ğ¹ Ğ½Ğ°Ğ±Ğ¾Ñ€ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ².

```go
// ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ interface
type Writer interface {
    Write(p []byte) (n int, err error)
}

type Reader interface {
    Read(p []byte) (n int, err error)
}

// ĞšĞ¾Ğ¼Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑĞ¾Ğ²
type ReadWriter interface {
    Reader
    Writer
}
```

**Duck Typing:**
```go
// Go Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ structural typing
// Ğ•ÑĞ»Ğ¸ Ñ‚Ğ¸Ğ¿ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·ÑƒĞµÑ‚ Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑĞ° â€” Ğ¾Ğ½ ÑƒĞ´Ğ¾Ğ²Ğ»ĞµÑ‚Ğ²Ğ¾Ñ€ÑĞµÑ‚ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑÑƒ

type File struct{}
func (f *File) Read(p []byte) (n int, err error) { return }
func (f *File) Write(p []byte) (n int, err error) { return }

// File Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·ÑƒĞµÑ‚ ReadWriter â€” no explicit declaration needed
```

**Empty Interface (`interface{}`):**
```go
// ĞŸÑ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°ĞµÑ‚ Ğ»ÑĞ±Ğ¾Ğ¹ Ñ‚Ğ¸Ğ¿
func PrintAny(v interface{}) {
    fmt.Println(v)
}

// Type assertion
if str, ok := v.(string); ok {
    fmt.Println("It's a string:", str)
}

// Type switch
switch t := v.(type) {
case string:
    fmt.Println("String:", t)
case int:
    fmt.Println("Int:", t)
default:
    fmt.Println("Unknown type")
}
```

**Interface Internals:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Interface Representation                 â”‚
â”‚                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Type pointer  â”‚  Value pointer     â”‚  â”‚
â”‚  â”‚  (itab)        â”‚  (data)            â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                           â”‚
â”‚  nil interface != interface with nil valueâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 3. Memory Management

**Ğ’Ğ¾Ğ¿Ñ€Ğ¾Ñ:** ĞšĞ°Ğº Go ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ Ğ¿Ğ°Ğ¼ÑÑ‚ÑŒÑ? ĞĞ±ÑŠÑÑĞ½Ğ¸Ñ‚Ğµ garbage collector Ğ¸ escape analysis.

**ĞÑ‚Ğ²ĞµÑ‚:**

**Heap vs Stack:**
```go
func example() {
    // Stack allocation (Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ğ¾)
    x := 10
    
    // Heap allocation (escape analysis)
    p := new(int)
    *p = 20
    
    // Returns pointer â€” must escape to heap
    return p
}
```

**Escape Analysis:**
```bash
# ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ³Ğ´Ğµ Ğ²Ñ‹Ğ´ĞµĞ»ÑĞµÑ‚ÑÑ Ğ¿Ğ°Ğ¼ÑÑ‚ÑŒ
go build -gcflags="-m" main.go

# Output:
# ./main.go:4:6: can inline example
# ./main.go:5:2: x escapes to heap
```

**Garbage Collector (GC):**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Go GC (Concurrent Mark-Sweep)             â”‚
â”‚                                                              â”‚
â”‚  1. Mark Phase:                                              â”‚
â”‚     â€¢ STW (Stop The World) â€” Ğ¾Ñ‡ĞµĞ½ÑŒ ĞºĞ¾Ñ€Ğ¾Ñ‚ĞºĞ¸Ğ¹                â”‚
â”‚     â€¢ Mark goroutines Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ÑÑ‚ concurrent Ñ Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ¾Ğ¹     â”‚
â”‚                                                              â”‚
â”‚  2. Sweep Phase:                                             â”‚
â”‚     â€¢ ĞÑ‡Ğ¸ÑÑ‚ĞºĞ° Ğ¿Ñ€Ğ¾Ğ¸ÑÑ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ¿Ğ¾ÑÑ‚ĞµĞ¿ĞµĞ½Ğ½Ğ¾ Ğ¼ĞµĞ¶Ğ´Ñƒ allocations      â”‚
â”‚                                                              â”‚
â”‚  Ğ¢Ñ€Ğ¸Ğ³Ğ³ĞµÑ€Ñ‹ GC:                                                â”‚
â”‚  â€¢ GOGC=100 (100% growth since last GC)                    â”‚
â”‚  â€¢ runtime.GC() (Ñ€ÑƒÑ‡Ğ½Ğ¾Ğ¹ Ğ²Ñ‹Ğ·Ğ¾Ğ²)                             â”‚
â”‚  â€¢ System memory pressure                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸:**
```go
// sync.Pool Ğ´Ğ»Ñ Ğ¿ĞµÑ€ĞµĞ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ¾Ğ²
var pool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 1024)
    },
}

// ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¸Ğ· Ğ¿ÑƒĞ»Ğ°
buf := pool.Get().([]byte)
// ... Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ ...
// Ğ’ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ğ² Ğ¿ÑƒĞ»
pool.Put(buf)
```

---

### 4. Error Handling

**Ğ’Ğ¾Ğ¿Ñ€Ğ¾Ñ:** ĞšĞ°Ğº Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº Ğ² Go? ĞĞ±ÑŠÑÑĞ½Ğ¸Ñ‚Ğµ `error` interface Ğ¸ best practices.

**ĞÑ‚Ğ²ĞµÑ‚:**

**Error Interface:**
```go
// Ğ¡Ñ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ñ‹Ğ¹ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ
type error interface {
    Error() string
}

// Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº
err := errors.New("something went wrong")
err := fmt.Errorf("wrapped error: %w", originalErr)
```

**Error Handling Pattern:**
```go
// Ğ¡Ñ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´
result, err := someFunction()
if err != nil {
    return fmt.Errorf("operation failed: %w", err)
}

// Sentinel errors (Ğ¿Ñ€ĞµĞ´Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ½Ñ‹Ğµ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸)
var ErrNotFound = errors.New("not found")

if errors.Is(err, ErrNotFound) {
    // Handle not found
}

// Custom error types
type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation failed: %s - %s", e.Field, e.Message)
}

// Type assertion
if ve, ok := err.(*ValidationError); ok {
    fmt.Println("Field:", ve.Field)
}

// errors.As (unwraps automatically)
var ve *ValidationError
if errors.As(err, &ve) {
    fmt.Println("Field:", ve.Field)
}
```

**Error Wrapping:**
```go
// Ğ’Ğ»Ğ¾Ğ¶ĞµĞ½Ğ½Ñ‹Ğµ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸
err := doSomething()
if err != nil {
    return fmt.Errorf("level 1: %w", err)
}

// Ğ Ğ°Ğ·Ğ²Ğ¾Ñ€Ğ°Ñ‡Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ
if errors.Unwrap(err) == io.EOF {
    // Ğ­Ñ‚Ğ¾ Ğ±Ñ‹Ğ»Ğ° EOF Ğ¾ÑˆĞ¸Ğ±ĞºĞ°
}
```

---

### 5. Synchronization Primitives

**Ğ’Ğ¾Ğ¿Ñ€Ğ¾Ñ:** ĞĞ±ÑŠÑÑĞ½Ğ¸Ñ‚Ğµ `sync.Mutex`, `sync.RWMutex`, `sync.WaitGroup`, `sync.Once`. ĞšĞ¾Ğ³Ğ´Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹?

**ĞÑ‚Ğ²ĞµÑ‚:**

**Mutex (Mutual Exclusion):**
```go
var mu sync.Mutex
counter := 0

// Ğ—Ğ°Ñ‰Ğ¸Ñ‚Ğ° shared state
mu.Lock()
counter++
mu.Unlock()

// Ğ˜Ğ»Ğ¸ Ñ defer
mu.Lock()
defer mu.Unlock()
// ... critical section ...
```

**RWMutex (Read-Write Mutex):**
```go
var rwmu sync.RWMutex
data := make(map[string]string)

// ĞœĞ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ¾ Ñ‡Ğ¸Ñ‚Ğ°Ñ‚ĞµĞ»ĞµĞ¹
rwmu.RLock()
value := data[key]
rwmu.RUnlock()

// ĞĞ´Ğ¸Ğ½ Ğ¿Ğ¸ÑĞ°Ñ‚ĞµĞ»ÑŒ
rwmu.Lock()
data[key] = value
rwmu.Unlock()
```

**WaitGroup:**
```go
var wg sync.WaitGroup

for i := 0; i < 3; i++ {
    wg.Add(1)
    go func(n int) {
        defer wg.Done()
        fmt.Printf("Worker %d done\n", n)
    }(i)
}

wg.Wait() // Ğ–Ğ´Ğ°Ñ‚ÑŒ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ Ğ²ÑĞµÑ…
fmt.Println("All done")
```

**Once:**
```go
var once sync.Once
var config *Config

func GetConfig() *Config {
    once.Do(func() {
        config = loadConfig() // Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ÑÑ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¾Ğ´Ğ¸Ğ½ Ñ€Ğ°Ğ·
    })
    return config
}
```

**Ğ¡Ñ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ğµ:**

| Primitive | Use Case |
|-----------|----------|
| `Mutex` | Exclusive access to shared resource |
| `RWMutex` | Many readers, few writers |
| `WaitGroup` | Wait for goroutines to complete |
| `Once` | One-time initialization |
| `Cond` | Signal/wait conditions |
| `Map` | Concurrent-safe map |
| `Pool` | Object reuse |

---

### 6. Concurrency Patterns

**Ğ’Ğ¾Ğ¿Ñ€Ğ¾Ñ:** ĞĞ¿Ğ¸ÑˆĞ¸Ñ‚Ğµ common concurrency patterns Ğ² Go: worker pool, fan-out/fan-in, pipeline, context cancellation.

**ĞÑ‚Ğ²ĞµÑ‚:**

**Worker Pool:**
```go
func workerPool(jobs <-chan int, results chan<- int, workers int) {
    var wg sync.WaitGroup
    
    for i := 0; i < workers; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for job := range jobs {
                results <- process(job)
            }
        }(i)
    }
    
    go func() {
        wg.Wait()
        close(results)
    }()
}
```

**Fan-Out / Fan-In:**
```go
// Fan-Out: Ñ€Ğ°Ğ·Ğ´ĞµĞ»ÑĞµĞ¼ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñƒ Ğ½Ğ° Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¾ goroutines
func fanOut(input <-chan int, n int) []<-chan int {
    workers := make([]<-chan int, n)
    for i := 0; i < n; i++ {
        workers[i] = process(input)
    }
    return workers
}

// Fan-In: Ğ¾Ğ±ÑŠĞµĞ´Ğ¸Ğ½ÑĞµĞ¼ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹
func fanIn(channels ...<-chan int) <-chan int {
    var wg sync.WaitGroup
    multiplexed := make(chan int)
    
    for _, ch := range channels {
        wg.Add(1)
        go func(c <-chan int) {
            defer wg.Done()
            for v := range c {
                multiplexed <- v
            }
        }(ch)
    }
    
    go func() {
        wg.Wait()
        close(multiplexed)
    }()
    
    return multiplexed
}
```

**Pipeline:**
```go
// Stage 1: Generate
func generate(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        for _, n := range nums {
            out <- n
        }
        close(out)
    }()
    return out
}

// Stage 2: Square
func square(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            out <- n * n
        }
        close(out)
    }()
    return out
}

// Usage: pipeline
for result := range square(generate(1, 2, 3, 4)) {
    fmt.Println(result) // 1, 4, 9, 16
}
```

**Context Cancellation:**
```go
// Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ context Ñ Ñ‚Ğ°Ğ¹Ğ¼Ğ°ÑƒÑ‚Ğ¾Ğ¼
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

// Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ñ deadline
ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(5*time.Second))

// Cancellation
ctx, cancel := context.WithCancel(context.Background())
defer cancel() // ĞÑ‚Ğ¼ĞµĞ½Ğ° Ğ¿Ñ€Ğ¸ Ğ²Ñ‹Ñ…Ğ¾Ğ´Ğµ

// ĞŸĞµÑ€ĞµĞ´Ğ°Ñ‡Ğ° values (use sparingly!)
ctx := context.WithValue(parentCtx, "key", "value")
```

---

### 7. Structs, Methods, Embedding

**Ğ’Ğ¾Ğ¿Ñ€Ğ¾Ñ:** ĞĞ±ÑŠÑÑĞ½Ğ¸Ñ‚Ğµ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹, Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹ Ğ¸ embedding Ğ² Go. Ğ’ Ñ‡ĞµĞ¼ Ñ€Ğ°Ğ·Ğ½Ğ¸Ñ†Ğ° Ğ¼ĞµĞ¶Ğ´Ñƒ value Ğ¸ pointer receivers?

**ĞÑ‚Ğ²ĞµÑ‚:**

**Structs:**
```go
type Person struct {
    Name string
    Age  int
}

// Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ
p := Person{Name: "Alice", Age: 30}
p2 := &Person{Name: "Bob"} // Pointer
p3 := new(Person)          // Pointer, zero values
```

**Methods:**
```go
// Value receiver (ĞºĞ¾Ğ¿Ğ¸Ñ)
func (p Person) GetName() string {
    return p.Name
}

// Pointer receiver (Ğ¼Ğ¾Ğ´Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ)
func (p *Person) Birthday() {
    p.Age++
}

// ĞšĞ¾Ğ³Ğ´Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ pointer:
// 1. ĞœĞµÑ‚Ğ¾Ğ´ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ¸Ğ·Ğ¼ĞµĞ½ÑÑ‚ÑŒ receiver
// 2. Ğ‘Ğ¾Ğ»ÑŒÑˆĞ¾Ğ¹ struct (Ğ¸Ğ·Ğ±ĞµĞ¶Ğ°Ñ‚ÑŒ ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ)
// 3. Consistency (ĞµÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ pointer Ğ¼ĞµÑ‚Ğ¾Ğ´ â€” Ğ²ÑĞµ pointer)
```

**Embedding (Composition over Inheritance):**
```go
type Animal struct {
    Name string
}

func (a *Animal) Speak() string {
    return "Some sound"
}

type Dog struct {
    Animal  // Embedded (promoted fields/methods)
    Breed string
}

// Dog Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ Ğ¼ĞµÑ‚Ğ¾Ğ´ Speak "Ğ±ĞµÑĞ¿Ğ»Ğ°Ñ‚Ğ½Ğ¾"
d := Dog{Animal: Animal{Name: "Buddy"}, Breed: "Labrador"}
fmt.Println(d.Name)   // "Buddy" (promoted)
fmt.Println(d.Speak()) // "Some sound"
```

**Value vs Pointer:**

| Aspect | Value Receiver | Pointer Receiver |
|--------|----------------|------------------|
| Copy | Yes | No |
| Can modify | No | Yes |
| Nil safety | Always safe | Can be nil |
| Use for | Small, immutable types | Large types, mutability |

---

### 8. Defer, Panic, Recover

**Ğ’Ğ¾Ğ¿Ñ€Ğ¾Ñ:** ĞšĞ°Ğº Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ÑÑ‚ defer, panic Ğ¸ recover? ĞšĞ°ĞºĞ¸Ğµ best practices?

**ĞÑ‚Ğ²ĞµÑ‚:**

**Defer:**
```go
// Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞµÑ‚ÑÑ Ğ² LIFO Ğ¿Ğ¾Ñ€ÑĞ´ĞºĞµ Ğ¿Ñ€Ğ¸ Ğ²Ñ‹Ñ…Ğ¾Ğ´Ğµ Ğ¸Ğ· Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
func example() {
    defer fmt.Println("1")
    defer fmt.Println("2")
    defer fmt.Println("3")
    fmt.Println("main")
    // Output: main, 3, 2, 1
}

// ĞŸÑ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¾Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ
func readFile(filename string) error {
    f, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer f.Close() // Ğ“Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾ Ğ·Ğ°ĞºÑ€Ğ¾ĞµÑ‚ÑÑ
    
    // ... Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ° Ñ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ¼ ...
    return nil
}

// Arguments evaluated immediately
defer func(x int) {
    fmt.Println(x) // 10 (not 20)
}(x)
x = 20
```

**Panic Ğ¸ Recover:**
```go
// Panic â€” Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ° Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ñ‹
func mayPanic() {
    panic("something went wrong")
}

// Recover â€” Ğ²Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ÑĞ»Ğµ panic
func safeCall() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered:", r)
        }
    }()
    
    mayPanic() // Ğ­Ñ‚Ğ¾Ñ‚ panic Ğ±ÑƒĞ´ĞµÑ‚ Ğ¿ĞµÑ€ĞµÑ…Ğ²Ğ°Ñ‡ĞµĞ½
}
```

**Best Practices:**
- **Defer**: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ğ´Ğ»Ñ cleanup (close, unlock)
- **Panic**: Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ Ğ½ĞµĞ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ¸Ğ¼Ñ‹Ñ… Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº (programmer errors)
- **Recover**: ĞĞ° Ğ²ĞµÑ€Ñ…Ğ½ĞµĞ¼ ÑƒÑ€Ğ¾Ğ²Ğ½Ğµ (HTTP handlers, goroutines)

```go
// Pattern: HTTP handler recovery
func recoveryMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        defer func() {
            if err := recover(); err != nil {
                log.Printf("Panic: %v", err)
                http.Error(w, "Internal Server Error", 500)
            }
        }()
        next.ServeHTTP(w, r)
    })
}
```

---

### 9. Testing

**Ğ’Ğ¾Ğ¿Ñ€Ğ¾Ñ:** ĞšĞ°Ğº Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒ Ñ‚ĞµÑÑ‚Ñ‹ Ğ² Go? ĞĞ±ÑŠÑÑĞ½Ğ¸Ñ‚Ğµ table-driven tests, mocking, benchmarking.

**ĞÑ‚Ğ²ĞµÑ‚:**

**Unit Tests:**
```go
// file: calculator.go
func Add(a, b int) int {
    return a + b
}

// file: calculator_test.go
func TestAdd(t *testing.T) {
    result := Add(2, 3)
    if result != 5 {
        t.Errorf("Add(2, 3) = %d; want 5", result)
    }
}
```

**Table-Driven Tests:**
```go
func TestAdd(t *testing.T) {
    tests := []struct {
        name     string
        a, b     int
        expected int
    }{
        {"positive", 2, 3, 5},
        {"negative", -2, -3, -5},
        {"zero", 0, 5, 5},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := Add(tt.a, tt.b)
            if result != tt.expected {
                t.Errorf("Add(%d, %d) = %d; want %d", 
                    tt.a, tt.b, result, tt.expected)
            }
        })
    }
}
```

**Benchmarking:**
```go
func BenchmarkAdd(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Add(2, 3)
    }
}

// Ğ—Ğ°Ğ¿ÑƒÑĞº: go test -bench=.
// Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚: 1000000000 ops/sec
```

**Mocking Ñ Interfaces:**
```go
// Ğ˜Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ Ğ´Ğ»Ñ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
type Database interface {
    GetUser(id string) (*User, error)
}

// Ğ ĞµĞ°Ğ»ÑŒĞ½Ğ°Ñ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ
type PostgresDB struct{}

// Mock Ğ´Ğ»Ñ Ñ‚ĞµÑÑ‚Ğ¾Ğ²
type MockDB struct {
    GetUserFunc func(id string) (*User, error)
}

func (m *MockDB) GetUser(id string) (*User, error) {
    return m.GetUserFunc(id)
}

// Ğ¢ĞµÑÑ‚
func TestService(t *testing.T) {
    mock := &MockDB{
        GetUserFunc: func(id string) (*User, error) {
            return &User{ID: id, Name: "Test"}, nil
        },
    }
    
    service := NewService(mock)
    // ... test service ...
}
```

---

### 10. Go Modules Ğ¸ Tooling

**Ğ’Ğ¾Ğ¿Ñ€Ğ¾Ñ:** ĞšĞ°Ğº Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ÑÑ‚ Go modules? ĞĞ±ÑŠÑÑĞ½Ğ¸Ñ‚Ğµ go.mod, versioning, vendoring.

**ĞÑ‚Ğ²ĞµÑ‚:**

**Go Modules (Go 1.11+):**
```bash
# Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¼Ğ¾Ğ´ÑƒĞ»Ñ
go mod init github.com/user/project

# Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸
go get github.com/gin-gonic/gin

# ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ
go get -u github.com/gin-gonic/gin
go get -u ./...  # Ğ²ÑĞµ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸

# ĞÑ‡Ğ¸ÑÑ‚ĞºĞ°
go mod tidy
```

**go.mod:**
```go
module github.com/user/project

go 1.21

require (
    github.com/gin-gonic/gin v1.9.1
    github.com/stretchr/testify v1.8.4
)

require (
    github.com/bytedance/sonic v1.9.1 // indirect
    // ...
)
```

**go.sum:**
```
// ĞšĞ¾Ğ½Ñ‚Ñ€Ğ¾Ğ»ÑŒĞ½Ñ‹Ğµ ÑÑƒĞ¼Ğ¼Ñ‹ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ñ†ĞµĞ»Ğ¾ÑÑ‚Ğ½Ğ¾ÑÑ‚Ğ¸
// ĞĞµ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²Ñ€ÑƒÑ‡Ğ½ÑƒÑ
github.com/gin-gonic/gin v1.9.1 h1:4idEAncQnuU8cHU7ZyxzlWUESCgla0L6p1QxAw...
github.com/gin-gonic/gin v1.9.1/go.mod h1:hntMpsV9FPj9pztL8UOwgv0M3l...
```

**Semantic Versioning:**
```go
// github.com/pkg/errors v0.9.1
//    â”‚      â”‚          â”‚ â”‚ â””â”€â”€ patch (bug fixes)
//    â”‚      â”‚          â”‚ â””â”€â”€â”€â”€ minor (new features, backwards compatible)
//    â”‚      â”‚          â””â”€â”€â”€â”€â”€â”€ major (breaking changes)
//    â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ repository
//    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ organization

// Major version 2+
import "github.com/pkg/errors/v2"
```

**Vendoring:**
```bash
# ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ²ÑĞµÑ… Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹ Ğ² vendor/
go mod vendor

# Ğ¡Ğ±Ğ¾Ñ€ĞºĞ° Ñ vendor
go build -mod=vendor

# Ğ˜Ğ»Ğ¸ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ Ğ¾ĞºÑ€ÑƒĞ¶ĞµĞ½Ğ¸Ñ
GOFLAGS="-mod=vendor"
```

**Useful Commands:**
```bash
go list -m all              # Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ²ÑĞµÑ… Ğ¼Ğ¾Ğ´ÑƒĞ»ĞµĞ¹
go mod graph                # Ğ“Ñ€Ğ°Ñ„ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹
go mod why -m module        # Ğ—Ğ°Ñ‡ĞµĞ¼ Ğ½ÑƒĞ¶Ğ½Ğ° Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ÑŒ
go mod download             # Ğ¡ĞºĞ°Ñ‡Ğ°Ñ‚ÑŒ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸
```

---

## ğŸ’» ĞŸÑ€Ğ°ĞºÑ‚Ğ¸ĞºĞ° / Go Tasks

### 1. HTTP Server

**Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ°:** ĞĞ°Ğ¿Ğ¸ÑˆĞ¸Ñ‚Ğµ production-ready HTTP ÑĞµÑ€Ğ²ĞµÑ€ Ñ graceful shutdown, middleware Ğ¸ routing.

**ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ°:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    HTTP Server Architecture                  â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚   Router    â”‚â”€â”€â–ºâ”‚ Middleware  â”‚â”€â”€â–ºâ”‚  Handler    â”‚       â”‚
â”‚  â”‚   (mux)     â”‚   â”‚ (logging,   â”‚   â”‚  (business  â”‚       â”‚
â”‚  â”‚             â”‚   â”‚  auth,      â”‚   â”‚   logic)    â”‚       â”‚
â”‚  â”‚             â”‚   â”‚  recovery)  â”‚   â”‚             â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                                              â”‚
â”‚  Graceful Shutdown:                                          â”‚
â”‚  1. ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ ÑĞ¸Ğ³Ğ½Ğ°Ğ» (SIGTERM, SIGINT)                       â”‚
â”‚  2. Stop accepting new connections                         â”‚
â”‚  3. Wait for active requests to complete                   â”‚
â”‚  4. Shutdown                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 2. Worker Pool

**Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ°:** Ğ ĞµĞ°Ğ»Ğ¸Ğ·ÑƒĞ¹Ñ‚Ğµ worker pool Ñ Ğ´Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¼ Ğ¼Ğ°ÑÑˆÑ‚Ğ°Ğ±Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸ĞµĞ¼ Ğ¸ ĞºĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ¼ Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‹.

**Ğ¢Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ:**
- ĞĞ°ÑÑ‚Ñ€Ğ°Ğ¸Ğ²Ğ°ĞµĞ¼Ğ¾Ğµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ workers
- Graceful shutdown Ñ‡ĞµÑ€ĞµĞ· context
- Retry logic Ğ´Ğ»Ñ failed jobs
- Metrics (Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¾, failed, Ğ² Ğ¾Ñ‡ĞµÑ€ĞµĞ´Ğ¸)

---

### 3. Concurrency Safe Cache

**Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ°:** Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ thread-safe ĞºĞµÑˆ Ñ TTL (Time-To-Live) eviction.

**Features:**
- Get, Set, Delete Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸
- ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¾Ğµ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ TTL
- Concurrent access Ğ±ĞµĞ· Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ¾Ğº (Ğ¸Ğ»Ğ¸ Ñ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¼Ğ¸)
- Cleanup goroutine

---

### 4. Pipeline

**Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ°:** Ğ ĞµĞ°Ğ»Ğ¸Ğ·ÑƒĞ¹Ñ‚Ğµ data processing pipeline Ñ Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½Ğ°Ğ¼Ğ¸.

**Stages:**
1. **Source:** Ñ‡Ñ‚ĞµĞ½Ğ¸Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¸Ğ· Ñ„Ğ°Ğ¹Ğ»Ğ°/API
2. **Filter:** Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ñ
3. **Transform:** Ğ¿Ñ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
4. **Sink:** Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ°

**Ğ¢Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ:**
- Context cancellation Ğ½Ğ° Ğ²ÑĞµÑ… ÑÑ‚Ğ°Ğ¿Ğ°Ñ…
- ĞĞ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ğµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ° concurrent workers
- Error handling Ğ¸ graceful shutdown

---

### 5. CLI Tool

**Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ°:** Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ CLI Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚ Ñ Ğ¿Ğ¾Ğ´ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ°Ğ¼Ğ¸ Ğ¸ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸ĞµĞ¹.

**Features:**
- Cobra Ğ¸Ğ»Ğ¸ ÑÑ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ñ‹Ğ¹ flag
- Subcommands (e.g., `tool config`, `tool run`, `tool status`)
- Configuration file support (JSON/YAML)
- Structured logging (slog/zap)
- Graceful shutdown
